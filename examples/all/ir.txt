package ir

import (
	"fmt"

	"github.com/alpha/internal/parser"
	"github.com/alpha/internal/semantic"
)

type IRBuilder struct {
	CurrentFunc *Function
	Module      *Module
}

func NewBuilder(mod *Module) *IRBuilder {
	return &IRBuilder{Module: mod}
}

// ============================
// Gerenciamento de Temporários e Labels
// ============================

func (b *IRBuilder) NewTemp(t semantic.Type) *Operand {
	id := b.CurrentFunc.TempCount
	b.CurrentFunc.TempCount++
	return &Operand{
		Kind:  OpTemp,
		Value: fmt.Sprintf("t%d", id),
		Type:  t,
	}
}

func (b *IRBuilder) NewLabel(prefix string) *Operand {
	id := b.CurrentFunc.LabelCount
	b.CurrentFunc.LabelCount++
	return &Operand{
		Kind:  OpLabel,
		Value: fmt.Sprintf("%s_%d", prefix, id),
	}
}

func (b *IRBuilder) Emit(op OpCode, arg1, arg2, result *Operand) *Instruction {
	instr := &Instruction{
		Op:     op,
		Arg1:   arg1,
		Arg2:   arg2,
		Result: result,
	}
	b.CurrentFunc.Instructions = append(b.CurrentFunc.Instructions, instr)
	return instr
}

func (b *IRBuilder) EmitLabel(label *Operand) {
	b.Emit(LABEL, label, nil, nil)
}

func (b *IRBuilder) EmitJump(label *Operand) {
	b.Emit(JMP, label, nil, nil)
}

func (b *IRBuilder) EmitCondJump(cond, trueLabel, falseLabel *Operand) {
	// Implementação corrigida de salto condicional
	if falseLabel != nil {
		b.Emit(JMP_FALSE, cond, falseLabel, nil)
	}
	if trueLabel != nil {
		b.Emit(JMP_TRUE, cond, trueLabel, nil)
	}
}

// ============================
// Helpers de Operandos
// ============================

func Literal(val string, t semantic.Type) *Operand {
	return &Operand{Kind: OpLiteral, Value: val, Type: t}
}

func Var(name string, t semantic.Type) *Operand {
	return &Operand{Kind: OpVar, Value: name, Type: t}
}

func IntLiteral(val int64) *Operand {
	return &Operand{
		Kind:  OpLiteral,
		Value: fmt.Sprintf("%d", val),
		Type:  &semantic.ParserTypeWrapper{Type: &parser.PrimitiveType{Name: "int"}},
	}
}

func BoolLiteral(val bool) *Operand {
	strVal := "false"
	if val {
		strVal = "true"
	}
	return &Operand{
		Kind:  OpLiteral,
		Value: strVal,
		Type:  &semantic.ParserTypeWrapper{Type: &parser.PrimitiveType{Name: "bool"}},
	}
}
package ir

import (
	"github.com/alpha/internal/parser"
	"github.com/alpha/internal/semantic"
)

type Generator struct {
	builder *IRBuilder
	checker *semantic.Checker // Para consultar tipos resolvidos
}

func NewGenerator(checker *semantic.Checker) *Generator {
	mod := &Module{
		Name:      "main", // Padrão, pode vir do PackageDecl
		Functions: make([]*Function, 0),
		Globals:   make([]*Instruction, 0),
	}
	return &Generator{
		builder: NewBuilder(mod),
		checker: checker,
	}
}

func (g *Generator) Generate(prog *parser.Program) *Module {
	// 1. Pré-passo: Registrar structs
	for _, stmt := range prog.Body {
		if s, ok := stmt.(*parser.StructDecl); ok {
			g.builder.Module.Structs = append(g.builder.Module.Structs, s)
		}
	}

	// 2. Geração de código (isso preencherá as funções e o corpo do init)
	for _, stmt := range prog.Body {
		g.genGlobalStmt(stmt)
	}

	// 3. FINALIZAÇÃO: Selar a função init
	// Procuramos a função 'init' que foi criada pelo ensureInitFunction
	for _, fn := range g.builder.Module.Functions {
		if fn.Name == "init" {
			// Verificamos se a última instrução já não é um RET
			// para evitar retornos duplicados
			lastIdx := len(fn.Instructions) - 1
			if lastIdx < 0 || fn.Instructions[lastIdx].Op != RET {
				// Forçamos o builder a apontar para o init e emitimos o retorno final
				g.builder.CurrentFunc = fn
				g.builder.Emit(RET, nil, nil, nil)
			}
		}
	}

	return g.builder.Module
}

// ============================
// Declarações Globais
// ============================

func (g *Generator) genGlobalStmt(stmt parser.Stmt) {
	switch s := stmt.(type) {
	case *parser.FunctionDecl:
		g.genFunction(s)
	case *parser.PackageDecl:
		g.builder.Module.Name = s.Name
	case *parser.VarDecl:
		g.genGlobalVarDecl(s)
	case *parser.ConstDecl:
		g.genGlobalConstDecl(s)
	}
}

func (g *Generator) genGlobalVarDecl(decl *parser.VarDecl) {
	// Inicialização de variáveis globais
	typ := g.resolveType(decl.Type)
	globalOp := &Operand{
		Kind:  OpVar,
		Value: decl.Name,
		Type:  typ,
	}

	// Armazenar no módulo como uma instrução de alocação
	g.builder.Module.Globals = append(g.builder.Module.Globals, &Instruction{
		Op:     ALLOCA,
		Result: globalOp,
		Arg1:   &Operand{Kind: OpType, Type: typ},
	})

	if decl.Init != nil {
		initFunc := g.ensureInitFunction()
		currentFunc := g.builder.CurrentFunc
		g.builder.CurrentFunc = initFunc

		val := g.genExpr(decl.Init)
		// Emitir MOV ao invés de STORE para globais
		globalOp := &Operand{
			Kind:  OpVar,
			Value: decl.Name,
			Type:  val.Type,
		}
		g.builder.Emit(MOV, val, nil, globalOp)

		g.builder.CurrentFunc = currentFunc
	}
}

func (g *Generator) genGlobalConstDecl(decl *parser.ConstDecl) {
	// Constantes globais são resolvidas em tempo de compilação
	// Usamos genExpr para obter o operando e seu tipo
	valOperand := g.genExpr(decl.Init)

	globalOp := &Operand{
		Kind:  OpVar,
		Value: decl.Name,
		Type:  valOperand.Type,
	}

	g.builder.Module.Globals = append(g.builder.Module.Globals, &Instruction{
		Op:     MOV,
		Result: globalOp,
		Arg1:   valOperand,
	})
}

func (g *Generator) ensureInitFunction() *Function {
	// Verifica se já existe uma função init
	for _, fn := range g.builder.Module.Functions {
		if fn.Name == "init" {
			return fn
		}
	}

	// Cria função init se não existir
	initFunc := &Function{
		Name:       "init",
		TempCount:  0,
		LabelCount: 0,
		IsExported: false,
	}

	// Adiciona ao módulo
	g.builder.Module.Functions = append(g.builder.Module.Functions, initFunc)

	// Se estamos no meio da geração de outra função,
	// precisamos garantir que a função init tenha um RET
	savedFunc := g.builder.CurrentFunc
	g.builder.CurrentFunc = initFunc

	// Restaura a função atual
	if savedFunc != nil {
		g.builder.CurrentFunc = savedFunc
	}

	return initFunc
}

func (g *Generator) resolveType(parserType parser.Type) semantic.Type {
	if parserType == nil {
		return nil
	}

	// Usamos o checker para resolver o tipo
	switch t := parserType.(type) {
	case *parser.PrimitiveType:
		return &semantic.ParserTypeWrapper{Type: t}
	case *parser.IdentifierType:
		// Para tipos definidos pelo usuário, por enquanto, retornamos um wrapper básico
		return &semantic.ParserTypeWrapper{Type: t}
	case *parser.ArrayType:
		// Por enquanto, não resolvemos o tipo do elemento recursivamente
		return &semantic.ParserTypeWrapper{
			Type: &parser.ArrayType{
				ElementType: &parser.PrimitiveType{Name: "any"}, // Simplificação
				Size:        t.Size,
			},
		}
	case *parser.PointerType:
		// Por enquanto, não resolvemos o tipo base recursivamente
		return &semantic.ParserTypeWrapper{
			Type: &parser.PointerType{
				BaseType: &parser.PrimitiveType{Name: "any"}, // Simplificação
			},
		}
	default:
		// Para outros tipos, retorna um tipo "any"
		return &semantic.ParserTypeWrapper{Type: &parser.PrimitiveType{Name: "any"}}
	}
}

func (g *Generator) genFunction(fn *parser.FunctionDecl) {
	irFunc := &Function{
		Name:       fn.Name,
		TempCount:  0,
		LabelCount: 0,
		IsExported: isExported(fn.Name),
		ReturnType: semantic.ToType(fn.ReturnTypes[0]),
	}

	generics := make([]string, 0)
	if fn.Generics != nil {
		for _, gen := range fn.Generics {
			generics = append(generics, gen.Name)
		}
	}
	irFunc.Generics = generics

	// Configurar builder para a nova função
	g.builder.CurrentFunc = irFunc

	// Processar parâmetros
	for _, param := range fn.Params {
		operand := Var(param.Name, semantic.ToType(param.Type))
		irFunc.Params = append(irFunc.Params, operand)
		// Em algumas arquiteturas, precisamos fazer STORE do param registro -> stack
	}

	// Gerar corpo
	for _, stmt := range fn.Body {
		g.genStmt(stmt)
	}

	g.builder.Module.Functions = append(g.builder.Module.Functions, irFunc)
}

// ============================
// Statements
// ============================

func (g *Generator) genStmt(stmt parser.Stmt) {
	switch s := stmt.(type) {
	case *parser.VarDecl:
		g.genVarDecl(s)
	case *parser.ExprStmt:
		g.genExpr(s.Expr) // Avalia expressão (efeitos colaterais)
	case *parser.ReturnStmt:
		g.genReturn(s)
	case *parser.IfStmt:
		g.genIf(s)
	case *parser.WhileStmt:
		g.genWhile(s)
	case *parser.ForStmt:
		g.genFor(s)
	case *parser.BlockStmt:
		for _, sub := range s.Body {
			g.genStmt(sub)
		}
	case *parser.SwitchStmt:
		g.genSwitch(s)
	case *parser.BreakStmt:
		g.genBreak()
	case *parser.ContinueStmt:
		g.genContinue()
	}
}

func (g *Generator) genVarDecl(decl *parser.VarDecl) {
	// ALLOCA type
	typ := semantic.ToType(decl.Type)
	varOp := Var(decl.Name, typ)

	// IR: %var = ALLOCA type
	g.builder.Emit(ALLOCA, &Operand{Kind: OpType, Type: typ}, nil, varOp)

	if decl.Init != nil {
		val := g.genExpr(decl.Init)
		// IR: STORE %var, %val
		g.builder.Emit(STORE, varOp, val, nil)
	}
}

func (g *Generator) genReturn(ret *parser.ReturnStmt) {
	if len(ret.Values) == 0 {
		g.builder.Emit(RET, nil, nil, nil)
		return
	}

	if len(ret.Values) == 1 {
		val := g.genExpr(ret.Values[0])
		g.builder.Emit(RET, val, nil, nil)
	} else {
		// Multi-return: criar uma struct temporária
		// Para simplificação, emitimos múltiplos valores em registros
		// (backend precisará lidar com isso)
		for _, expr := range ret.Values {
			val := g.genExpr(expr)
			g.builder.Emit(RET, val, nil, nil)
		}
	}
}

func (g *Generator) genIf(stmt *parser.IfStmt) {
	cond := g.genExpr(stmt.Cond)

	trueLabel := g.builder.NewLabel("if_then")
	elseLabel := g.builder.NewLabel("if_else")
	endLabel := g.builder.NewLabel("if_end")

	targetElse := elseLabel
	if stmt.Else == nil {
		targetElse = endLabel
	}

	// Se for falso, pula para o else/fim
	g.builder.Emit(JMP_FALSE, cond, targetElse, nil)

	// Bloco Then
	g.builder.EmitLabel(trueLabel)
	for _, s := range stmt.Then {
		g.genStmt(s)
	}
	g.builder.Emit(JMP, endLabel, nil, nil)

	// Bloco Else (se existir)
	if stmt.Else != nil {
		g.builder.EmitLabel(elseLabel)
		for _, s := range stmt.Else {
			g.genStmt(s)
		}
	}

	g.builder.EmitLabel(endLabel)
}

func (g *Generator) genWhile(stmt *parser.WhileStmt) {
	startLabel := g.builder.NewLabel("while_start")
	endLabel := g.builder.NewLabel("while_end")

	// Empilhar labels para break/continue
	prevBreak := g.builder.CurrentFunc.LabelCount
	g.builder.CurrentFunc.LabelCount += 2

	g.builder.EmitLabel(startLabel)

	cond := g.genExpr(stmt.Cond)
	g.builder.Emit(JMP_FALSE, cond, endLabel, nil)

	for _, s := range stmt.Body {
		g.genStmt(s)
	}

	g.builder.Emit(JMP, startLabel, nil, nil)
	g.builder.EmitLabel(endLabel)

	// Restaurar labels
	g.builder.CurrentFunc.LabelCount = prevBreak
}

func (g *Generator) genFor(stmt *parser.ForStmt) {
	// Escopo do for
	if stmt.Init != nil {
		g.genStmt(stmt.Init)
	}

	startLabel := g.builder.NewLabel("for_start")
	condLabel := g.builder.NewLabel("for_cond")
	endLabel := g.builder.NewLabel("for_end")

	g.builder.Emit(JMP, condLabel, nil, nil)
	g.builder.EmitLabel(startLabel)

	for _, s := range stmt.Body {
		g.genStmt(s)
	}

	if stmt.Post != nil {
		g.genStmt(stmt.Post)
	}

	g.builder.EmitLabel(condLabel)
	if stmt.Cond != nil {
		cond := g.genExpr(stmt.Cond)
		g.builder.Emit(JMP_TRUE, cond, startLabel, nil)
	} else {
		g.builder.Emit(JMP, startLabel, nil, nil)
	}

	g.builder.EmitLabel(endLabel)
}

func (g *Generator) genSwitch(stmt *parser.SwitchStmt) {
	// Implementação simplificada de switch
	expr := g.genExpr(stmt.Expr)
	endLabel := g.builder.NewLabel("switch_end")

	for _, clause := range stmt.Cases {
		caseLabel := g.builder.NewLabel("case")

		if clause.Value != nil {
			caseVal := g.genExpr(clause.Value)
			cond := g.builder.NewTemp(nil)
			g.builder.Emit(EQ, expr, caseVal, cond)
			g.builder.Emit(JMP_TRUE, cond, caseLabel, nil)
		} else {
			// default case
			g.builder.EmitLabel(caseLabel)
		}

		for _, bodyStmt := range clause.Body {
			g.genStmt(bodyStmt)
		}
		g.builder.Emit(JMP, endLabel, nil, nil)
	}

	g.builder.EmitLabel(endLabel)
}

func (g *Generator) genBreak() {
	// Implementação simplificada: pular para o fim do loop mais interno
	endLabel := g.builder.NewLabel("loop_end")
	g.builder.Emit(JMP, endLabel, nil, nil)
}

func (g *Generator) genContinue() {
	// Implementação simplificada: pular para o início do loop mais interno
	startLabel := g.builder.NewLabel("loop_start")
	g.builder.Emit(JMP, startLabel, nil, nil)
}

// ============================
// Expressões
// ============================

func (g *Generator) genExpr(expr parser.Expr) *Operand {
	switch e := expr.(type) {
	case *parser.IntLiteral:
		return IntLiteral(e.Value)
	case *parser.BoolLiteral:
		return BoolLiteral(e.Value)
	case *parser.StringLiteral:
		return Literal(e.Value, nil) // Tipo string
	case *parser.Identifier:
		// Assumimos que semantic check já resolveu se existe
		return Var(e.Name, nil)
	case *parser.BinaryExpr:
		return g.genBinaryExpr(e)
	case *parser.CallExpr:
		return g.genCallExpr(e)
	case *parser.AssignExpr:
		return g.genAssign(e)
	case *parser.IndexExpr:
		return g.genIndexExpr(e)
	case *parser.MemberExpr:
		return g.genMemberExpr(e)
	case *parser.UnaryExpr:
		return g.genUnaryExpr(e)
	case *parser.TernaryExpr:
		return g.genTernaryExpr(e)
	case *parser.TypeCastExpr:
		return g.genTypeCast(e)
	default:
		// Fallback para outros tipos não implementados aqui
		return g.builder.NewTemp(nil)
	}
}

func (g *Generator) genUnaryExpr(e *parser.UnaryExpr) *Operand {
	expr := g.genExpr(e.Expr)
	res := g.builder.NewTemp(nil)

	if e.Postfix {
		// Para pós-fixo (i++), retornar valor original, depois incrementar
		temp := g.builder.NewTemp(nil)
		g.builder.Emit(MOV, expr, nil, temp)
		g.builder.Emit(ADD, expr, Literal("1", nil), expr)
		return temp
	}

	switch e.Op {
	case "-":
		g.builder.Emit(SUB, Literal("0", nil), expr, res)
	case "!":
		g.builder.Emit(XOR, expr, Literal("1", nil), res)
	case "&":
		// Operador de endereço
		return g.genAddr(e.Expr)
	case "*":
		// Dereferenciação de ponteiro
		g.builder.Emit(LOAD, expr, nil, res)
	default:
		g.builder.Emit(MOV, expr, nil, res)
	}
	return res
}

func (g *Generator) genTernaryExpr(e *parser.TernaryExpr) *Operand {
	cond := g.genExpr(e.Cond)
	trueLabel := g.builder.NewLabel("ternary_true")
	falseLabel := g.builder.NewLabel("ternary_false")
	endLabel := g.builder.NewLabel("ternary_end")

	result := g.builder.NewTemp(nil)

	g.builder.Emit(JMP_FALSE, cond, falseLabel, nil)
	g.builder.EmitLabel(trueLabel)
	trueVal := g.genExpr(e.TrueExpr)
	g.builder.Emit(MOV, trueVal, nil, result)
	g.builder.Emit(JMP, endLabel, nil, nil)

	g.builder.EmitLabel(falseLabel)
	falseVal := g.genExpr(e.FalseExpr)
	g.builder.Emit(MOV, falseVal, nil, result)

	g.builder.EmitLabel(endLabel)
	return result
}

func (g *Generator) genTypeCast(e *parser.TypeCastExpr) *Operand {
	expr := g.genExpr(e.Expr)
	res := g.builder.NewTemp(semantic.ToType(e.Type))

	// Emitir instrução CAST
	g.builder.Emit(CAST, expr, nil, res)
	return res
}

func (g *Generator) genBinaryExpr(e *parser.BinaryExpr) *Operand {
	// Curto circuito para && e ||
	if e.Op == "&&" || e.Op == "||" {
		return g.genLogicalShortCircuit(e)
	}

	left := g.genExpr(e.Left)
	right := g.genExpr(e.Right)

	// Determina OpCode
	var op OpCode
	switch e.Op {
	case "+":
		op = ADD
	case "-":
		op = SUB
	case "*":
		op = MUL
	case "/":
		op = DIV
	case "%":
		op = MOD
	case "==":
		op = EQ
	case "!=":
		op = NEQ
	case "<":
		op = LT
	case ">":
		op = GT
	case "<=":
		op = LE
	case ">=":
		op = GE
	case "&":
		op = AND
	case "|":
		op = OR
	case "^":
		op = XOR
	case "<<":
		op = SHL
	case ">>":
		op = SHR
	default:
		panic("Unknown operator " + e.Op)
	}

	result := g.builder.NewTemp(nil)
	g.builder.Emit(op, left, right, result)
	return result
}

func (g *Generator) genLogicalShortCircuit(e *parser.BinaryExpr) *Operand {
	result := g.builder.NewTemp(nil)
	left := g.genExpr(e.Left)

	endLabel := g.builder.NewLabel("logic_end")

	if e.Op == "&&" {
		// left && right
		g.builder.Emit(JMP_FALSE, left, endLabel, nil)
		right := g.genExpr(e.Right)
		g.builder.Emit(MOV, right, nil, result)
	} else { // ||
		// left || right
		g.builder.Emit(JMP_TRUE, left, endLabel, nil)
		right := g.genExpr(e.Right)
		g.builder.Emit(MOV, right, nil, result)
	}

	g.builder.EmitLabel(endLabel)
	return result
}

func (g *Generator) genCallExpr(e *parser.CallExpr) *Operand {
	var args []*Operand
	for _, arg := range e.Args {
		args = append(args, g.genExpr(arg))
	}

	// Resolve callee
	var callee *Operand
	if ident, ok := e.Callee.(*parser.Identifier); ok {
		// Trata built-ins
		if isBuiltin(ident.Name) {
			return g.genBuiltin(ident.Name, args)
		}
		callee = &Operand{Kind: OpFunction, Value: ident.Name}
	} else {
		callee = g.genExpr(e.Callee) // Ponteiro de função
	}

	result := g.builder.NewTemp(nil)

	instr := g.builder.Emit(CALL, callee, nil, result)
	instr.Args = args

	return result
}

func (g *Generator) genBuiltin(name string, args []*Operand) *Operand {
	res := g.builder.NewTemp(nil)

	switch name {
	case "length":
		g.builder.Emit(LEN, args[0], nil, res)
	case "append":
		if len(args) < 2 {
			panic("append requires 2 arguments")
		}
		g.builder.Emit(APPEND, args[0], args[1], res)
	case "remove":
		// remove(&arr, element)
		g.builder.Emit(REMOVE, args[0], args[1], res)
	case "removeIndex":
		// removeIndex(&arr, index)
		g.builder.Emit(REMOVE_INDEX, args[0], args[1], res)
	case "delete":
		// delete(&map, key)
		g.builder.Emit(DELETE, args[0], args[1], res)
	case "add":
		// add(&set, value)
		g.builder.Emit(ADD, args[0], args[1], res)
	case "clear":
		// clear(&map)
		g.builder.Emit(CLEAR, args[0], nil, res)
	case "has":
		// has(&set, value) -> retorna bool
		g.builder.Emit(HAS, args[0], args[1], res)
	default:
		// Para funções não mapeadas, tratamos como uma chamada genérica de sistema
		g.builder.Emit(CALL, &Operand{Kind: OpFunction, Value: "builtin_" + name}, nil, res)
	}
	return res
}

func (g *Generator) genAssign(e *parser.AssignExpr) *Operand {
	val := g.genExpr(e.Right)

	// Se Left for identificador simples
	if ident, ok := e.Left.(*parser.Identifier); ok {
		dest := Var(ident.Name, nil)
		g.builder.Emit(STORE, dest, val, nil)
		return val
	}

	// Se for acesso complexo (array/struct), precisamos do endereço
	addr := g.genAddr(e.Left)
	g.builder.Emit(STORE, addr, val, nil)

	return val
}

func (g *Generator) genIndexExpr(e *parser.IndexExpr) *Operand {
	arr := g.genExpr(e.Array)
	idx := g.genExpr(e.Index)
	res := g.builder.NewTemp(nil)
	g.builder.Emit(GET_INDEX, arr, idx, res)
	return res
}

func (g *Generator) genMemberExpr(e *parser.MemberExpr) *Operand {
	obj := g.genExpr(e.Object)
	field := &Operand{Kind: OpField, Value: e.Member}
	res := g.builder.NewTemp(nil)
	g.builder.Emit(GET_FIELD, obj, field, res)
	return res
}

// Helpers
func (g *Generator) genAddr(expr parser.Expr) *Operand {
	// Lógica para obter endereço de memória ao invés do valor
	switch e := expr.(type) {
	case *parser.Identifier:
		return Var(e.Name, nil)
	case *parser.IndexExpr:
		// Calcula endereço do elemento
		arr := g.genExpr(e.Array)
		idx := g.genExpr(e.Index)
		res := g.builder.NewTemp(nil)
		g.builder.Emit(GET_ADDR, arr, idx, res)
		return res
	case *parser.MemberExpr:
		obj := g.genExpr(e.Object)
		field := &Operand{Kind: OpField, Value: e.Member}
		res := g.builder.NewTemp(nil)
		g.builder.Emit(GET_ADDR, obj, field, res)
		return res
	default:
		panic("Cannot take address of this expression")
	}
}

func isBuiltin(name string) bool {
	builtins := map[string]bool{
		"append": true, "length": true, "remove": true, "delete": true,
		"add": true, "clear": true, "has": true, "removeIndex": true,
	}
	return builtins[name]
}

func isExported(name string) bool {
	// Exemplo: letra maiúscula exporta
	if len(name) > 0 {
		return name[0] >= 'A' && name[0] <= 'Z'
	}
	return false
}
package ir

import (
	"fmt"
	"strings"

	"github.com/alpha/internal/parser"
	"github.com/alpha/internal/semantic"
)

// OpCode representa a operação a ser executada
type OpCode int

const (
	// Aritmética e Lógica
	ADD OpCode = iota
	SUB
	MUL
	DIV
	MOD
	AND
	OR
	XOR
	SHL
	SHR

	// Comparação
	EQ
	NEQ
	LT
	GT
	LE
	GE

	// Memória e Atribuição
	MOV       // t1 = t2
	LOAD      // t1 = *t2
	STORE     // *t1 = t2
	ALLOCA    // t1 = alloc type
	GET_FIELD // t1 = t2.field (offset calculation)
	GET_INDEX // t1 = t2[t3]
	GET_ADDR  // t1 = &t2

	// Controle de Fluxo
	LABEL     // Definição de label
	JMP       // Pulo incondicional
	JMP_TRUE  // Pulo se verdadeiro
	JMP_FALSE // Pulo se falso
	CALL      // Chamada de função
	RET       // Retorno de função
	PHI       // Para SSA (opcional, incluído para extensibilidade)

	// Built-ins e Especiais
	LEN        // t1 = len(t2)
	APPEND     // t1 = append(t1, t2)
	MAKE_SLICE // t1 = make([]T, len)
	MAKE_MAP   // t1 = make(map[K]V)
	CAST       // t1 = type(t2)
	NOP        // No Operation

	// Operações para built-ins (adicionadas)
	REMOVE       // remove(&arr, element)
	REMOVE_INDEX // removeIndex(&arr, index)
	DELETE       // delete(&map, key)
	CLEAR        // clear(&map | &set)
	HAS          // has(&set, value)
)

// OperandType define o tipo do operando
type OperandType int

const (
	OpVar      OperandType = iota // Variável do usuário
	OpTemp                        // Variável temporária do compilador (%t1)
	OpLiteral                     // Literal (número, string)
	OpLabel                       // Label de salto (.L1)
	OpFunction                    // Nome de função
	OpType                        // Referência a tipo (para allocs)
	OpField                       // Nome de campo de struct
)

// Operand representa um argumento de uma instrução
type Operand struct {
	Kind  OperandType
	Value string        // Representação string do valor
	Type  semantic.Type // Tipo semântico associado (para backend)
}

func (o Operand) String() string {
	switch o.Kind {
	case OpTemp:
		return "%" + o.Value
	case OpLabel:
		return "." + o.Value
	case OpLiteral:
		if o.Type != nil && strings.Contains(semantic.StringifyType(o.Type), "string") {
			return `"` + o.Value + `"`
		}
		return o.Value
	default:
		return o.Value
	}
}

// Instruction representa uma linha de código no IR (Quadruple)
// Formato: Result = Op Arg1, Arg2
type Instruction struct {
	Op     OpCode
	Arg1   *Operand
	Arg2   *Operand
	Result *Operand
	Args   [](*Operand) // Para instruções com número variável de argumentos (ex: CALL)
	// Metadados adicionais para debug ou backend específico
	Line int
}

func (i *Instruction) String() string {
	opStr := i.opToString()

	if i.Op == LABEL {
		return fmt.Sprintf("%s:", i.Arg1)
	}

	var sb strings.Builder
	if i.Result != nil {
		sb.WriteString(fmt.Sprintf("%s = ", i.Result))
	}

	sb.WriteString(opStr)

	if i.Arg1 != nil {
		sb.WriteString(" ")
		sb.WriteString(i.Arg1.String())
	}
	if i.Arg2 != nil {
		sb.WriteString(", ")
		sb.WriteString(i.Arg2.String())
	}

	// Para CALL com múltiplos argumentos
	if i.Op == CALL && len(i.Args) > 0 {
		sb.WriteString("(")
		for j, arg := range i.Args {
			if j > 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(arg.String())
		}
		sb.WriteString(")")
	}
	return sb.String()
}

func (i *Instruction) opToString() string {
	// Mapeamento simples para debug
	names := []string{
		"ADD", "SUB", "MUL", "DIV", "MOD", "AND", "OR", "XOR", "SHL", "SHR",
		"EQ", "NEQ", "LT", "GT", "LE", "GE",
		"MOV", "LOAD", "STORE", "ALLOCA", "GET_FIELD", "GET_INDEX", "GET_ADDR",
		"LABEL", "JMP", "JMP_TRUE", "JMP_FALSE", "CALL", "RET", "PHI",
		"LEN", "APPEND", "MAKE_SLICE", "MAKE_MAP", "CAST", "NOP",
		"REMOVE", "REMOVE_INDEX", "DELETE", "CLEAR", "HAS", // Novas operações
	}
	if int(i.Op) < len(names) {
		return names[i.Op]
	}
	return "UNKNOWN"
}

// BasicBlock representa uma sequência linear de instruções
type BasicBlock struct {
	Label        string
	Instructions []*Instruction
	Predecessors []*BasicBlock
	Successors   []*BasicBlock
}

// Function representa uma função compilada no IR
type Function struct {
	Name         string
	Receiver     string
	Params       []*Operand
	Instructions []*Instruction // Representação linear
	TempCount    int            // Contador para variáveis temporárias
	LabelCount   int            // Contador para labels
	ReturnType   semantic.Type
	IsExported   bool
	Generics     []string
	// Pilha de labels para break/continue
	BreakLabels    []string
	ContinueLabels []string
}

// Module representa o programa inteiro (pacote)
type Module struct {
	Name      string
	Imports   []string
	Globals   []*Instruction // Inicialização de globais
	Functions []*Function
	Structs   []*parser.StructDecl // Metadados de structs para backend
}
package ir

import (
	"fmt"
	"strconv"
)

// Optimizer orquestra as transformações no IR
type Optimizer struct {
	Module *Module // Referência ao módulo definido em ir.txt
}

func NewOptimizer(mod *Module) *Optimizer {
	return &Optimizer{Module: mod}
}

// Optimize percorre todas as funções do módulo para aplicar melhorias
func (o *Optimizer) Optimize() {
	for _, fn := range o.Module.Functions {
		o.ConstantFolding(fn)
		o.EliminateUnreachableCode(fn)
	}
}

// ConstantFolding simplifica expressões matemáticas com literais
func (o *Optimizer) ConstantFolding(fn *Function) {
	for _, instr := range fn.Instructions {
		// Verifica se os argumentos são do tipo OpLiteral [cite: 20]
		if instr.Arg1 != nil && instr.Arg1.Kind == OpLiteral &&
			instr.Arg2 != nil && instr.Arg2.Kind == OpLiteral {

			val1, _ := strconv.ParseInt(instr.Arg1.Value, 10, 64)
			val2, _ := strconv.ParseInt(instr.Arg2.Value, 10, 64)
			var result int64

			switch instr.Op {
			case ADD: // Definido no seu iota de OpCode [cite: 18]
				result = val1 + val2
			case SUB:
				result = val1 - val2
			case MUL: // [cite: 23]
				result = val1 * val2
			case DIV:
				if val2 != 0 {
					result = val1 / val2
				} else {
					continue // Não dobrar divisão por zero
				}
			default:
				continue
			}

			// Transforma a instrução complexa em um simples MOV [cite: 18]
			instr.Op = MOV
			instr.Arg1 = &Operand{Kind: OpLiteral, Value: fmt.Sprintf("%d", result)}
			instr.Arg2 = nil
		}
	}
}

// EliminateUnreachableCode remove código após JMP ou RET que não tenha Label
func (o *Optimizer) EliminateUnreachableCode(fn *Function) {
	optimized := make([]*Instruction, 0, len(fn.Instructions))
	unreachable := false
	labels := make(map[string]bool)

	// Primeira passagem: coletar todos os labels
	for _, instr := range fn.Instructions {
		if instr.Op == LABEL && instr.Arg1 != nil {
			labels[instr.Arg1.String()] = true
		}
	}

	// Segunda passagem: eliminar código inalcançável
	for i, instr := range fn.Instructions {
		// Se encontrarmos um LABEL, o fluxo pode voltar a este ponto [cite: 18]
		if instr.Op == LABEL {
			unreachable = false
		}

		if !unreachable {
			optimized = append(optimized, instr)
		}

		// JMP e RET encerram o fluxo linear do bloco atual [cite: 18]
		if instr.Op == JMP || instr.Op == RET {
			// Verificar se o próximo bloco começa com um label
			// Se não, marca como inalcançável
			if i+1 < len(fn.Instructions) {
				nextInstr := fn.Instructions[i+1]
				if nextInstr.Op != LABEL {
					unreachable = true
				}
			} else {
				unreachable = true
			}
		}
	}
	fn.Instructions = optimized
}
