package codegen

import (
	"github.com/alpha/internal/ir"
	"github.com/alpha/internal/parser"
	"github.com/alpha/internal/semantic"
)

// CodeGenerator é o ponto de entrada principal para geração de código
type CodeGenerator struct {
	checker *semantic.Checker
	module  *ir.Module
}

func NewCodeGenerator(checker *semantic.Checker) *CodeGenerator {
	return &CodeGenerator{
		checker: checker,
	}
}

// GenerateCode gera código Go a partir do IR otimizado
func (cg *CodeGenerator) GenerateCode(module *ir.Module) string {
	cg.module = module

	// Pipeline de otimização
	pipeline := NewPipeline(module)

	// Compilar
	return pipeline.Compile()
}

// GenerateFromAST gera código diretamente da AST (atalho)
func (cg *CodeGenerator) GenerateFromAST(prog *parser.Program) string {
	// 1. Gerar IR
	generator := ir.NewGenerator(cg.checker)
	module := generator.Generate(prog)

	// 2. Otimizar
	optimizer := ir.NewOptimizer(module)
	optimizer.Optimize()

	// 3. Gerar código
	return cg.GenerateCode(module)
}
package codegen

import (
	"fmt"
	"go/format"
	"strings"
	"unicode"

	"github.com/alpha/internal/ir"
	"github.com/alpha/internal/parser"
	"github.com/alpha/internal/semantic"
)

type OptimizedEmitter struct {
	module     *ir.Module
	output     strings.Builder
	typeMapper *TypeMapper
	tempPool   *TempPool
	labelCount int
	loopStack  []LoopContext
	inFunction string
	funcVars   map[string]VarInfo
}

type VarInfo struct {
	Type     string
	IsTemp   bool
	IsLocal  bool
	IsParam  bool
	IsGlobal bool
}

type LoopContext struct {
	StartLabel    string
	EndLabel      string
	ContinueLabel string
}

type TempPool struct {
	available map[string][]string // tipo -> lista de temps disponíveis
	nextID    int
}

func NewTempPool() *TempPool {
	return &TempPool{
		available: make(map[string][]string),
		nextID:    0,
	}
}

func (tp *TempPool) Get(typ string) string {
	if pool, ok := tp.available[typ]; ok && len(pool) > 0 {
		temp := pool[len(pool)-1]
		tp.available[typ] = pool[:len(pool)-1]
		return temp
	}

	temp := fmt.Sprintf("t%d", tp.nextID)
	tp.nextID++
	return temp
}

func (tp *TempPool) Return(temp string, typ string) {
	tp.available[typ] = append(tp.available[typ], temp)
}

func NewOptimizedEmitter(mod *ir.Module) *OptimizedEmitter {
	return &OptimizedEmitter{
		module:     mod,
		typeMapper: NewTypeMapper(),
		tempPool:   NewTempPool(),
		funcVars:   make(map[string]VarInfo),
	}
}

func (e *OptimizedEmitter) Emit() string {
	e.output.Reset()

	// Header
	e.output.WriteString("// Code generated by Alpha Compiler v1.0\n")
	e.output.WriteString("// DO NOT EDIT\n\n")
	e.output.WriteString("package main\n\n")

	// Imports otimizados
	e.emitImports()

	// Runtime
	e.output.WriteString(GetRuntime())

	// Structs com layout otimizado
	e.emitStructs()

	// Globals
	e.emitGlobals()

	// Functions
	for _, fn := range e.module.Functions {
		e.emitFunction(fn)
	}

	// Main wrapper se necessário
	if e.hasMainFunction() {
		e.emitMainWrapper()
	}

	// Formata o código Go
	formatted, err := format.Source([]byte(e.output.String()))
	if err != nil {
		// Fallback para código não formatado
		return e.output.String()
	}

	return string(formatted)
}

func (e *OptimizedEmitter) emitImports() {
	if len(e.module.Imports) == 0 && !e.moduleHasMaps() {
		return
	}

	e.output.WriteString("import (\n")

	// Imports essenciais
	imports := []string{
		"fmt",
	}

	// Adiciona imports condicionais baseado no código
	if e.moduleHasMaps() {
		imports = append(imports, `"sync"`)
	}

	for _, imp := range imports {
		e.output.WriteString("\t" + imp + "\n")
	}

	e.output.WriteString(")\n\n")
}

func (e *OptimizedEmitter) emitStructs() {
	for _, s := range e.module.Structs {
		e.emitStructWithLayout(s)
	}
}

func (e *OptimizedEmitter) emitStructWithLayout(s *parser.StructDecl) {
	decl := fmt.Sprintf("type %s", s.Name)

	if len(s.Generics) > 0 {
		var params []string
		for _, g := range s.Generics {
			// "any" é a constraint padrão do Go 1.18+
			params = append(params, fmt.Sprintf("%s any", g.Name))
		}
		decl += fmt.Sprintf("[%s]", strings.Join(params, ", "))
	}

	decl += " struct {\n"
	e.output.WriteString(decl)

	// Agrupa campos por tamanho para melhor alinhamento
	fieldsBySize := make(map[string][]*parser.FieldDecl)
	for _, field := range s.Fields {
		semType := semantic.ToType(field.Type)
		goType := e.typeMapper.ToGoType(semType)

		sizeKey := e.getTypeSizeKey(goType)
		fieldsBySize[sizeKey] = append(fieldsBySize[sizeKey], field)
	}

	// Emite campos em ordem de tamanho (maiores primeiro)
	sizeOrder := []string{"ptr", "64", "32", "16", "8", "bool"}
	for _, size := range sizeOrder {
		if fields, ok := fieldsBySize[size]; ok {
			for _, field := range fields {
				semType := semantic.ToType(field.Type)
				goType := e.typeMapper.ToGoType(semType)
				fieldName := e.exportFieldName(field.Name)

				e.output.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
			}
		}
	}

	e.output.WriteString("}\n\n")

	// Emite métodos se existirem
	e.emitStructMethods(s)
}

func (e *OptimizedEmitter) getTypeSizeKey(goType string) string {
	switch {
	case strings.HasPrefix(goType, "*") ||
		strings.HasPrefix(goType, "[]") ||
		strings.HasPrefix(goType, "map[") ||
		goType == "string" ||
		goType == "interface{}":
		return "ptr"
	case goType == "int64" || goType == "float64" || goType == "uint64":
		return "64"
	case goType == "int32" || goType == "float32" || goType == "uint32":
		return "32"
	case goType == "int16" || goType == "uint16":
		return "16"
	case goType == "int8" || goType == "uint8" || goType == "byte":
		return "8"
	case goType == "bool":
		return "bool"
	default:
		return "ptr" // assume ponteiro para tipos customizados
	}
}

func (e *OptimizedEmitter) emitStructMethods(s *parser.StructDecl) {
	// Para cada função que tem receiver deste struct
	for _, fn := range e.module.Functions {
		if e.isMethodOf(fn, s.Name) {
			e.emitMethod(fn, s.Name)
		}
	}
}

func (e *OptimizedEmitter) isMethodOf(fn *ir.Function, structName string) bool {
	// Verifica se o primeiro parâmetro é o receiver
	if len(fn.Params) > 0 {
		firstParam := fn.Params[0]
		if strings.Contains(firstParam.Value, "self") ||
			strings.Contains(firstParam.Value, "this") {
			return true
		}
	}
	return false
}

func (e *OptimizedEmitter) emitMethod(fn *ir.Function, structName string) {
	receiverName := "self"
	if len(fn.Params) > 0 {
		receiverName = fn.Params[0].Value
	}

	receiverType := structName
	if e.typeMapper.IsReferenceType(e.typeMapper.ToGoType(fn.Params[0].Type)) {
		receiverType = "*" + receiverType
	}

	e.output.WriteString(fmt.Sprintf("func (%s %s) %s(",
		receiverName, receiverType, fn.Name))

	// Parâmetros (excluindo receiver)
	for i := 1; i < len(fn.Params); i++ {
		p := fn.Params[i]
		goType := e.typeMapper.ToGoType(p.Type)
		if i > 1 {
			e.output.WriteString(", ")
		}
		e.output.WriteString(fmt.Sprintf("%s %s", p.Value, goType))
	}

	// Tipo de retorno
	if fn.ReturnType != nil {
		retType := e.typeMapper.ToGoType(fn.ReturnType)
		if retType != "" {
			e.output.WriteString(fmt.Sprintf(") %s {\n", retType))
		} else {
			e.output.WriteString(") {\n")
		}
	} else {
		e.output.WriteString(") {\n")
	}

	// Corpo do método
	e.inFunction = fn.Name
	e.emitFunctionBody(fn)

	e.output.WriteString("}\n\n")
	e.inFunction = ""
}

func (e *OptimizedEmitter) emitFunction(fn *ir.Function) {
	if e.isMethodOf(fn, "") {
		return // Já foi emitido como método
	}

	e.inFunction = fn.Name
	e.funcVars = make(map[string]VarInfo)

	// Assinatura
	e.output.WriteString(fmt.Sprintf("func %s", fn.Name))

	if len(fn.Generics) > 0 {
		var params []string
		for _, g := range fn.Generics {
			params = append(params, fmt.Sprintf("%s any", g))
		}
		e.output.WriteString(fmt.Sprintf("[%s]", strings.Join(params, ", ")))
	}

	e.output.WriteString("(")

	// Parâmetros
	for i, p := range fn.Params {
		goType := e.typeMapper.ToGoType(p.Type)
		if i > 0 {
			e.output.WriteString(", ")
		}
		e.output.WriteString(fmt.Sprintf("%s %s", p.Value, goType))

		// Registra variável
		e.funcVars[p.Value] = VarInfo{
			Type:    goType,
			IsParam: true,
		}
	}

	// Retorno
	retType := ""
	if fn.ReturnType != nil {
		retType = e.typeMapper.ToGoType(fn.ReturnType)
		if retType != "" {
			e.output.WriteString(fmt.Sprintf(") %s {\n", retType))
		} else {
			e.output.WriteString(") {\n")
		}
	} else {
		e.output.WriteString(") {\n")
	}

	// Otimização: Stack allocation para variáveis locais
	e.emitLocalVariables(fn)

	// Corpo
	e.emitFunctionBody(fn)

	e.output.WriteString("}\n\n")
	e.inFunction = ""
}

func (e *OptimizedEmitter) emitLocalVariables(fn *ir.Function) {
	// Coleta todos os temporários usados
	tempsUsed := make(map[string]bool)

	for _, instr := range fn.Instructions {
		if instr.Result != nil && instr.Result.Kind == ir.OpTemp {
			tempsUsed[instr.Result.Value] = true
		}
	}

	// Emite declarações agrupadas por tipo
	tempsByType := make(map[string][]string)

	for i := 0; i < fn.TempCount; i++ {
		tempName := fmt.Sprintf("t%d", i)
		if !tempsUsed[tempName] {
			continue
		}

		// Determina tipo do temporário
		tempType := e.inferTempType(fn, tempName)
		tempsByType[tempType] = append(tempsByType[tempType], tempName)
	}

	// Emite declarações otimizadas
	for typ, temps := range tempsByType {
		if len(temps) == 1 {
			e.output.WriteString(fmt.Sprintf("\tvar %s %s\n", temps[0], typ))
		} else {
			e.output.WriteString(fmt.Sprintf("\tvar %s %s\n",
				strings.Join(temps, ", "), typ))
		}
	}

	if len(tempsByType) > 0 {
		e.output.WriteString("\n")
	}
}

func (e *OptimizedEmitter) inferTempType(fn *ir.Function, tempName string) string {
	// Procura instruções que definem o temporário
	for _, instr := range fn.Instructions {
		if instr.Result != nil && instr.Result.Value == tempName {
			if instr.Result.Type != nil {
				return e.typeMapper.ToGoType(instr.Result.Type)
			}

			// Inferência baseada na operação
			switch instr.Op {
			case ir.ADD, ir.SUB, ir.MUL, ir.DIV, ir.MOD:
				return "int"
			case ir.EQ, ir.NEQ, ir.LT, ir.GT, ir.LE, ir.GE:
				return "bool"
			case ir.GET_FIELD, ir.GET_INDEX:
				// Tenta inferir do argumento
				if instr.Arg1 != nil {
					if varInfo, ok := e.funcVars[instr.Arg1.Value]; ok {
						return e.typeMapper.GetElementType(varInfo.Type)
					}
				}
			}
		}
	}

	return "interface{}" // Fallback
}

func (e *OptimizedEmitter) emitFunctionBody(fn *ir.Function) {
	// Converte instruções para Go
	for _, instr := range fn.Instructions {
		e.emitOptimizedInstruction(instr)
	}
}

func (e *OptimizedEmitter) emitOptimizedInstruction(instr *ir.Instruction) {
	switch instr.Op {
	case ir.LABEL:
		e.output.WriteString(fmt.Sprintf("%s:\n", instr.Arg1.Value))

	case ir.JMP:
		e.output.WriteString(fmt.Sprintf("\tgoto %s\n", instr.Arg1.Value))

	case ir.JMP_FALSE:
		cond := e.emitOperand(instr.Arg1)
		label := instr.Arg2.Value
		e.output.WriteString(fmt.Sprintf("\tif !%s { goto %s }\n", cond, label))

	case ir.JMP_TRUE:
		cond := e.emitOperand(instr.Arg1)
		label := instr.Arg2.Value
		e.output.WriteString(fmt.Sprintf("\tif %s { goto %s }\n", cond, label))

	case ir.CALL:
		e.emitCall(instr)

	case ir.RET:
		if instr.Arg1 != nil {
			val := e.emitOperand(instr.Arg1)
			e.output.WriteString(fmt.Sprintf("\treturn %s\n", val))
		} else {
			e.output.WriteString("\treturn\n")
		}

	case ir.MOV:
		dst := e.emitOperand(instr.Result)
		src := e.emitOperand(instr.Arg1)
		e.output.WriteString(fmt.Sprintf("\t%s = %s\n", dst, src))

	case ir.ADD, ir.SUB, ir.MUL, ir.DIV, ir.MOD:
		e.emitBinaryOp(instr)

	case ir.EQ, ir.NEQ, ir.LT, ir.GT, ir.LE, ir.GE:
		e.emitComparison(instr)

	case ir.GET_FIELD:
		e.emitFieldAccess(instr)

	case ir.GET_INDEX:
		e.emitIndexAccess(instr)

	case ir.LOAD:
		e.emitLoad(instr)

	case ir.STORE:
		e.emitStore(instr)

	case ir.ALLOCA:
		e.emitAlloca(instr)

	case ir.MAKE_SLICE:
		e.emitMakeSlice(instr)

	case ir.MAKE_MAP:
		e.emitMakeMap(instr)

	case ir.LEN:
		e.emitLen(instr)

	case ir.APPEND:
		e.emitAppend(instr)

	case ir.CAST:
		// Usa emitOperand que é o nome correto no seu emmiter.go
		dst := e.emitOperand(instr.Result)
		src := e.emitOperand(instr.Arg1)

		// Usa o e.typeMapper que já está definido no seu OptimizedEmitter
		targetType := e.typeMapper.ToGoType(instr.Result.Type)

		// Lógica de conversão
		switch targetType {
		case "string":
			// No Alpha, string(int) costuma ser conversão de valor, não cast de byte
			e.output.WriteString(fmt.Sprintf("\t%s = fmt.Sprintf(\"%%v\", %s)\n", dst, src))
		case "int", "float64":
			e.output.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", dst, targetType, src))
		default:
			e.output.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", dst, targetType, src))
		}

	default:
		e.output.WriteString(fmt.Sprintf("\t// Unhandled op: %d\n", instr.Op))
	}
}

func (e *OptimizedEmitter) emitBinaryOp(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	left := e.emitOperand(instr.Arg1)
	right := e.emitOperand(instr.Arg2)

	var op string
	switch instr.Op {
	case ir.ADD:
		op = "+"
	case ir.SUB:
		op = "-"
	case ir.MUL:
		op = "*"
	case ir.DIV:
		op = "/"
	case ir.MOD:
		op = "%"
	}

	e.output.WriteString(fmt.Sprintf("\t%s = %s %s %s\n", dst, left, op, right))
}

func (e *OptimizedEmitter) emitComparison(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	left := e.emitOperand(instr.Arg1)
	right := e.emitOperand(instr.Arg2)

	var op string
	switch instr.Op {
	case ir.EQ:
		op = "=="
	case ir.NEQ:
		op = "!="
	case ir.LT:
		op = "<"
	case ir.GT:
		op = ">"
	case ir.LE:
		op = "<="
	case ir.GE:
		op = ">="
	}

	e.output.WriteString(fmt.Sprintf("\t%s = %s %s %s\n", dst, left, op, right))
}

func (e *OptimizedEmitter) emitFieldAccess(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	obj := e.emitOperand(instr.Arg1)
	field := instr.Arg2.Value

	// Converte para PascalCase para exportação Go
	fieldName := e.exportFieldName(field)

	e.output.WriteString(fmt.Sprintf("\t%s = %s.%s\n", dst, obj, fieldName))
}

func (e *OptimizedEmitter) emitIndexAccess(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	arr := e.emitOperand(instr.Arg1)
	idx := e.emitOperand(instr.Arg2)

	e.output.WriteString(fmt.Sprintf("\t%s = %s[%s]\n", dst, arr, idx))
}

func (e *OptimizedEmitter) emitLoad(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	src := e.emitOperand(instr.Arg1)

	e.output.WriteString(fmt.Sprintf("\t%s = *%s\n", dst, src))
}

func (e *OptimizedEmitter) emitStore(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Arg1)
	src := e.emitOperand(instr.Arg2)

	// Verifica se é variável global (não começa com % ou t)
	if strings.HasPrefix(dst, "%") || strings.HasPrefix(dst, "t") {
		e.output.WriteString(fmt.Sprintf("\t*%s = %s\n", dst, src))
	} else {
		e.output.WriteString(fmt.Sprintf("\t%s = %s\n", dst, src))
	}
}

func (e *OptimizedEmitter) emitAlloca(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	goType := e.typeMapper.ToGoType(instr.Arg1.Type)

	if e.typeMapper.CanUseStack(goType) {
		// Alocação na stack
		zeroVal := e.typeMapper.ZeroValue(goType)
		e.output.WriteString(fmt.Sprintf("\t%s = %s\n", dst, zeroVal))
	} else {
		// Alocação no heap
		e.output.WriteString(fmt.Sprintf("\t%s = new(%s)\n", dst, goType))
	}
}

func (e *OptimizedEmitter) emitMakeSlice(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	goType := e.typeMapper.ToGoType(instr.Result.Type)
	length := e.emitOperand(instr.Arg1)

	e.output.WriteString(fmt.Sprintf("\t%s = make(%s, %s)\n", dst, goType, length))
}

func (e *OptimizedEmitter) emitMakeMap(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	goType := e.typeMapper.ToGoType(instr.Result.Type)

	e.output.WriteString(fmt.Sprintf("\t%s = make(%s)\n", dst, goType))
}

func (e *OptimizedEmitter) emitLen(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	arr := e.emitOperand(instr.Arg1)

	e.output.WriteString(fmt.Sprintf("\t%s = int(len(%s))\n", dst, arr))
}

func (e *OptimizedEmitter) emitAppend(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	slice := e.emitOperand(instr.Arg1)
	val := e.emitOperand(instr.Arg2)

	// Usa runtime otimizado
	e.output.WriteString(fmt.Sprintf("\t%s = AlphaAppend(%s, %s)\n", dst, slice, val))
}

func (e *OptimizedEmitter) emitOperand(op *ir.Operand) string {
	if op == nil {
		return ""
	}

	switch op.Kind {
	case ir.OpLiteral:
		// Adiciona aspas para strings
		if op.Type != nil && semantic.StringifyType(op.Type) == "string" {
			return fmt.Sprintf(`"%s"`, op.Value)
		}
		return op.Value

	case ir.OpTemp:
		return op.Value

	case ir.OpVar:
		return op.Value

	case ir.OpLabel:
		return op.Value

	case ir.OpFunction:
		return op.Value

	default:
		return op.Value
	}
}

func (e *OptimizedEmitter) exportFieldName(name string) string {
	// Converte para PascalCase
	if len(name) == 0 {
		return name
	}

	// Verifica se já está em PascalCase
	first := rune(name[0])
	if unicode.IsUpper(first) {
		return name
	}

	// Converte primeira letra para maiúscula
	return string(unicode.ToUpper(first)) + name[1:]
}

func (e *OptimizedEmitter) emitGlobals() {
	if len(e.module.Globals) > 0 {
		e.output.WriteString("// Global variables\n")
		e.output.WriteString("var (\n")

		for _, instr := range e.module.Globals {
			if instr.Op == ir.ALLOCA && instr.Result != nil {
				goType := e.typeMapper.ToGoType(instr.Arg1.Type)
				e.output.WriteString(fmt.Sprintf("\t%s %s\n",
					instr.Result.Value, goType))
			}
		}

		e.output.WriteString(")\n\n")
	}
}

func (e *OptimizedEmitter) emitMainWrapper() {
	e.output.WriteString(`func main() {
	// Inicialização do runtime
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintf(os.Stderr, "Panic: %v\n", r)
			os.Exit(1)
		}
	}()
	
	// Chama função main do Alpha
	main()
}
`)
}

func (e *OptimizedEmitter) hasMainFunction() bool {
	for _, fn := range e.module.Functions {
		if fn.Name == "main" {
			return true
		}
	}
	return false
}

func (e *OptimizedEmitter) moduleHasMaps() bool {
	// Verifica se há operações com mapas no módulo
	for _, fn := range e.module.Functions {
		for _, instr := range fn.Instructions {
			if instr.Op == ir.MAKE_MAP {
				return true
			}
		}
	}
	return false
}

// Adicione ao final do arquivo emitter.go

func (e *OptimizedEmitter) emitRemove(instr *ir.Instruction) {
	slice := e.emitOperand(instr.Arg1)
	element := e.emitOperand(instr.Arg2)
	// Implementação para remover elemento de slice
	e.output.WriteString(fmt.Sprintf("\t%s = removeElement(%s, %s)\n",
		slice, slice, element))
}

func (e *OptimizedEmitter) emitRemoveIndex(instr *ir.Instruction) {
	slice := e.emitOperand(instr.Arg1)
	index := e.emitOperand(instr.Arg2)
	e.output.WriteString(fmt.Sprintf("\t%s = append(%s[:%s], %s[%s+1:]...)\n",
		slice, slice, index, slice, index))
}

func (e *OptimizedEmitter) emitDelete(instr *ir.Instruction) {
	m := e.emitOperand(instr.Arg1)
	key := e.emitOperand(instr.Arg2)
	e.output.WriteString(fmt.Sprintf("\tdelete(%s, %s)\n", m, key))
}

func (e *OptimizedEmitter) emitClear(instr *ir.Instruction) {
	target := e.emitOperand(instr.Arg1)
	e.output.WriteString(fmt.Sprintf("\tclear(%s)\n", target))
}

func (e *OptimizedEmitter) emitHas(instr *ir.Instruction) {
	set := e.emitOperand(instr.Arg1)
	value := e.emitOperand(instr.Arg2)
	dst := e.emitOperand(instr.Result)
	e.output.WriteString(fmt.Sprintf("\t_, %s = %s[%s]\n", dst, set, value))
}

// Adicione suporte para CAST
func (e *OptimizedEmitter) emitCast(instr *ir.Instruction) {
	dst := e.emitOperand(instr.Result)
	src := e.emitOperand(instr.Arg1)
	targetType := e.typeMapper.ToGoType(instr.Result.Type)

	// Conversões básicas
	switch targetType {
	case "string":
		e.output.WriteString(fmt.Sprintf("\t%s = fmt.Sprintf(\"%%v\", %s)\n", dst, src))
	case "int":
		e.output.WriteString(fmt.Sprintf("\t%s = int(%s)\n", dst, src))
	case "float64":
		e.output.WriteString(fmt.Sprintf("\t%s = float64(%s)\n", dst, src))
	default:
		e.output.WriteString(fmt.Sprintf("\t%s = %s(%s)\n", dst, targetType, src))
	}
}

// Melhore a emissão de chamadas
func (e *OptimizedEmitter) emitCall(instr *ir.Instruction) {
	dst := ""
	if instr.Result != nil {
		dst = e.emitOperand(instr.Result) + " = "
	}

	funcName := e.emitOperand(instr.Arg1)

	// Construir lista de argumentos
	var args []string
	if len(instr.Args) > 0 {
		for _, arg := range instr.Args {
			args = append(args, e.emitOperand(arg))
		}
	} else {
		// Usar Arg1 e Arg2 se Args estiver vazio
		if instr.Arg1 != nil && instr.Arg1.Kind != ir.OpFunction {
			args = append(args, e.emitOperand(instr.Arg1))
		}
		if instr.Arg2 != nil {
			args = append(args, e.emitOperand(instr.Arg2))
		}
	}

	e.output.WriteString(fmt.Sprintf("\t%s%s(%s)\n", dst, funcName, strings.Join(args, ", ")))
}
package codegen

import (
	"fmt"
	"strings"

	"github.com/alpha/internal/parser"
	"github.com/alpha/internal/semantic"
)

// TypeMapper gerencia conversões de tipos Alpha -> Go
type TypeMapper struct {
	structTypes map[string]string // cache de tipos de struct
	unionTypes  map[string]string // cache de union types
}

func NewTypeMapper() *TypeMapper {
	return &TypeMapper{
		structTypes: make(map[string]string),
		unionTypes:  make(map[string]string),
	}
}

// ToGoType converte tipos Alpha para Go mantendo Generics
func (tm *TypeMapper) ToGoType(t semantic.Type) string {
	if t == nil {
		return "" // void
	}

	// Desembrulha o ParserTypeWrapper se necessário
	if wrapper, ok := t.(*semantic.ParserTypeWrapper); ok {
		return tm.mapParserType(wrapper.Type)
	}

	// Fallback para tipos manuais ou strings
	return tm.mapSimpleString(semantic.StringifyType(t))
}

func (tm *TypeMapper) mapSimpleString(s string) string {
	switch s {
	case "int":
		return "int64"
	case "float":
		return "float64"
	case "bool":
		return "bool"
	case "string":
		return "string"
	case "void":
		return ""
	case "any":
		return "interface{}"
	case "byte":
		return "byte"
	case "char":
		return "rune"
	case "error":
		return "error"
	default:
		// Presume ser um tipo definido pelo usuário
		return s
	}
}

// GetElementType extrai o tipo elemento de arrays/slices
func (tm *TypeMapper) GetElementType(goType string) string {
	if strings.HasPrefix(goType, "[]") {
		return goType[2:]
	}
	if strings.HasPrefix(goType, "map[") {
		// Extrai tipo valor de map[K]V
		parts := strings.SplitN(goType, "]", 2)
		if len(parts) == 2 {
			return parts[1]
		}
	}
	return goType
}

// IsReferenceType verifica se o tipo é passado por referência
func (tm *TypeMapper) IsReferenceType(goType string) bool {
	return strings.HasPrefix(goType, "*") ||
		strings.HasPrefix(goType, "[]") ||
		strings.HasPrefix(goType, "map[") ||
		strings.HasPrefix(goType, "interface{}")
}

// ZeroValue retorna valor zero otimizado
func (tm *TypeMapper) ZeroValue(goType string) string {
	switch goType {
	case "int64", "float64":
		return "0"
	case "bool":
		return "false"
	case "string":
		return `""`
	case "byte":
		return "0"
	case "rune":
		return "0"
	default:
		if strings.HasPrefix(goType, "*") ||
			strings.HasPrefix(goType, "[]") ||
			strings.HasPrefix(goType, "map[") ||
			goType == "interface{}" ||
			goType == "error" {
			return "nil"
		}
		// Para structs, retorna struct literal vazia
		return goType + "{}"
	}
}

// CanUseStack verifica se o tipo pode ser alocado na stack
func (tm *TypeMapper) CanUseStack(goType string) bool {
	// Tipos pequenos podem ir para stack
	smallTypes := map[string]bool{
		"int64":   true,
		"float64": true,
		"bool":    true,
		"byte":    true,
		"rune":    true,
	}

	if smallTypes[goType] {
		return true
	}

	// Ponteiros para tipos pequenos também
	if strings.HasPrefix(goType, "*") {
		base := goType[1:]
		return smallTypes[base] || base == "string"
	}

	return false
}

func (tm *TypeMapper) mapParserType(t parser.Type) string {
	switch pt := t.(type) {
	case *parser.PrimitiveType:
		switch pt.Name {
		case "int":
			return "int"
		case "float":
			return "float64"
		case "bool":
			return "bool"
		case "string":
			return "string"
		case "byte":
			return "byte"
		case "char":
			return "rune"
		case "error":
			return "error"
		case "void":
			return ""
		default:
			return "interface{}"
		}

	case *parser.IdentifierType:
		// Tipos definidos pelo usuário
		return pt.Name

	case *parser.GenericType:
		// Para tipos genéricos, usamos interface{} como fallback
		if len(pt.TypeArgs) == 0 {
			return pt.Name
		}
		return "interface{}"

	case *parser.ArrayType:
		elemType := tm.mapParserType(pt.ElementType)
		return "[]" + elemType

	case *parser.MapType:
		keyType := tm.mapParserType(pt.KeyType)
		valueType := tm.mapParserType(pt.ValueType)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)

	case *parser.PointerType:
		baseType := tm.mapParserType(pt.BaseType)
		return "*" + baseType

	case *parser.NullableType:
		baseType := tm.mapParserType(pt.BaseType)
		return "*" + baseType

	case *parser.UnionType:
		// Para union types, usamos interface{}
		return "interface{}"

	case *parser.SetType:
		elemType := tm.mapParserType(pt.ElementType)
		return fmt.Sprintf("map[%s]struct{}", elemType)

	default:
		return "interface{}"
	}
}
package codegen

import (
	"strings"

	"github.com/alpha/internal/ir"
)

type CompilationPipeline struct {
	module        *ir.Module
	optimizer     *ir.Optimizer
	registerAlloc *RegisterAllocator
}

func NewPipeline(module *ir.Module) *CompilationPipeline {
	return &CompilationPipeline{
		module:        module,
		optimizer:     ir.NewOptimizer(module),
		registerAlloc: NewRegisterAllocator(),
	}
}

func (p *CompilationPipeline) Compile() string {
	// Fase 1: Otimizações no IR
	p.optimizer.Optimize()

	// Fase 2: Alocação de registros
	for _, fn := range p.module.Functions {
		p.registerAlloc.Allocate(fn)
	}

	// Fase 3: Geração de código
	emitter := NewOptimizedEmitter(p.module)
	code := emitter.Emit()

	// Fase 4: Pós-processamento
	code = p.postProcess(code)

	return code
}

func (p *CompilationPipeline) postProcess(code string) string {
	// Remove código morto após goto
	lines := strings.Split(code, "\n")
	var result []string
	unreachable := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Detecta goto incondicional
		if strings.HasPrefix(trimmed, "goto") && !strings.Contains(trimmed, "if") {
			unreachable = true
			result = append(result, line)
		} else if strings.HasSuffix(trimmed, ":") {
			unreachable = false
			result = append(result, line)
		} else if !unreachable || strings.HasPrefix(trimmed, "//") {
			result = append(result, line)
		}
	}

	// Remove variáveis não utilizadas
	result = p.removeUnusedVars(result)

	return strings.Join(result, "\n")
}

func (p *CompilationPipeline) removeUnusedVars(lines []string) []string {
	usedVars := make(map[string]bool)

	// Primeira passagem: coleta variáveis usadas
	for _, line := range lines {
		if strings.Contains(line, "var ") {
			continue
		}

		// Extrai identificadores
		words := strings.FieldsFunc(line, func(r rune) bool {
			return r == ' ' || r == '=' || r == '+' || r == '-' || r == '*' ||
				r == '/' || r == '[' || r == ']' || r == '(' || r == ')' ||
				r == ',' || r == ';' || r == ':' || r == '{' || r == '}'
		})

		for _, word := range words {
			if strings.HasPrefix(word, "t") && len(word) > 1 {
				// Verifica se é um número após o 't'
				allDigits := true
				for _, ch := range word[1:] {
					if ch < '0' || ch > '9' {
						allDigits = false
						break
					}
				}
				if allDigits {
					usedVars[word] = true
				}
			}
		}
	}

	// Segunda passagem: remove declarações não usadas
	var result []string
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "var t") {
			varName := strings.Fields(trimmed)[1]
			if used, exists := usedVars[varName]; !exists || !used {
				continue // Remove declaração não usada
			}
		}
		result = append(result, line)
	}

	return result
}

type OptimizationPass interface {
	Apply(*ir.Module)
}

type ConstantPropagation struct{}
type DeadCodeElimination struct{}
type InlineSmallFunctions struct{}
type LoopUnrolling struct{}
type RegisterAllocation struct{}

func (cp *ConstantPropagation) Apply(m *ir.Module) {
	for _, fn := range m.Functions {
		cp.applyToFunction(fn)
	}
}

func (cp *ConstantPropagation) applyToFunction(fn *ir.Function) {
	// Implementação simplificada
	constants := make(map[string]*ir.Operand)

	for i := 0; i < len(fn.Instructions); i++ {
		instr := fn.Instructions[i]

		// Propaga constantes
		if instr.Op == ir.MOV && instr.Arg1 != nil && instr.Arg1.Kind == ir.OpLiteral {
			constants[instr.Result.Value] = instr.Arg1
		}

		// Substitui usos de constantes
		if instr.Arg1 != nil && constants[instr.Arg1.Value] != nil {
			instr.Arg1 = constants[instr.Arg1.Value]
		}
		if instr.Arg2 != nil && constants[instr.Arg2.Value] != nil {
			instr.Arg2 = constants[instr.Arg2.Value]
		}
	}
}
package codegen

import "github.com/alpha/internal/ir"

type RegisterAllocator struct {
	registers map[string]int // variável -> registro
	nextReg   int
}

func NewRegisterAllocator() *RegisterAllocator {
	return &RegisterAllocator{
		registers: make(map[string]int),
		nextReg:   0,
	}
}

func (ra *RegisterAllocator) Allocate(fn *ir.Function) {
	// Para cada variável, atribui um "registro" (na prática, otimiza o uso de variáveis)

	// 1. Coleta variáveis vivas
	liveRanges := ra.computeLiveRanges(fn)

	// 2. Ordena por uso
	sortedVars := ra.sortByUse(fn)

	// 3. Atribui "registros"
	for _, varName := range sortedVars {
		if range_, exists := liveRanges[varName]; exists {
			// Tenta reusar registro
			reg := ra.findAvailableRegister(range_)
			ra.registers[varName] = reg
		}
	}
}

func (ra *RegisterAllocator) computeLiveRanges(fn *ir.Function) map[string][]int {
	ranges := make(map[string][]int)

	for i, instr := range fn.Instructions {
		// Definições
		if instr.Result != nil {
			varName := instr.Result.Value
			ranges[varName] = append(ranges[varName], i)
		}

		// Usos
		if instr.Arg1 != nil {
			varName := instr.Arg1.Value
			ranges[varName] = append(ranges[varName], i)
		}
		if instr.Arg2 != nil {
			varName := instr.Arg2.Value
			ranges[varName] = append(ranges[varName], i)
		}
	}

	return ranges
}

func (ra *RegisterAllocator) sortByUse(fn *ir.Function) []string {
	useCount := make(map[string]int)

	for _, instr := range fn.Instructions {
		if instr.Arg1 != nil {
			useCount[instr.Arg1.Value]++
		}
		if instr.Arg2 != nil {
			useCount[instr.Arg2.Value]++
		}
	}

	// Ordena por frequência de uso (decrescente)
	var sorted []string
	for varName := range useCount {
		sorted = append(sorted, varName)
	}

	// TODO: Implementar ordenação por uso
	return sorted
}

func (ra *RegisterAllocator) findAvailableRegister(range_ []int) int {
	// Algoritmo simplificado: retorna próximo registro disponível
	reg := ra.nextReg
	ra.nextReg++
	return reg
}

func (ra *RegisterAllocator) GetRegister(varName string) int {
	if reg, ok := ra.registers[varName]; ok {
		return reg
	}
	return -1
}
package codegen

// GetRuntime retorna o código Go padrão que todo arquivo precisa ter
func GetRuntime() string {
	return ``
}
