package codegen

import (
	"fmt"
	"strings"

	"github.com/alpha/internal/ir"
	"github.com/alpha/internal/semantic"
)

type Emitter struct {
	Module *ir.Module
	Output strings.Builder
}

func NewEmitter(mod *ir.Module) *Emitter {
	return &Emitter{Module: mod}
}

func (e *Emitter) Emit() string {
	e.Output.WriteString("// Code generated by Alpha Compiler\n")
	e.Output.WriteString("package main\n\n")
	e.Output.WriteString("import (\n\t\"fmt\"\n)\n")

	// Mantemos o runtime apenas para funções auxiliares (len, append)
	// Mas não para aritmética básica
	e.Output.WriteString(GetRuntime())

	e.emitStructs()

	for _, fn := range e.Module.Functions {
		e.emitFunction(fn)
	}

	return e.Output.String()
}

func (e *Emitter) emitStructs() {
	for _, s := range e.Module.Structs {
		e.Output.WriteString(fmt.Sprintf("type %s struct {\n", s.Name))
		for _, field := range s.Fields {
			semType := field.Type.(semantic.Type)
			goType := ToGoType(semType)

			// Go idiomatizado: Campos de struct começam com Maiúscula para serem exportados
			fieldName := strings.ToUpper(field.Name[:1]) + field.Name[1:]

			e.Output.WriteString(fmt.Sprintf("\t%s %s\n", fieldName, goType))
		}
		e.Output.WriteString("}\n\n")
	}
}

func (e *Emitter) emitFunction(fn *ir.Function) {
	// 1. Assinatura da Função
	e.Output.WriteString(fmt.Sprintf("func %s(", fn.Name))

	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		// O IR deve ter o Type no Operand do parâmetro
		goType := ToGoType(p.Type)
		params[i] = fmt.Sprintf("%s %s", sanitizeName(p.Value), goType)
	}
	e.Output.WriteString(strings.Join(params, ", "))

	retType := ""
	if fn.ReturnType != nil {
		t := ToGoType(fn.ReturnType)
		if t != "" {
			retType = t
		}
	}
	e.Output.WriteString(") " + retType + " {\n")

	// 2. Declaração de Variáveis Locais e Temporárias (Tipadas!)
	// Precisamos varrer as instruções para saber os tipos dos temporários (t0, t1...)
	tempTypes := e.collectTempTypes(fn)

	if len(tempTypes) > 0 {
		e.Output.WriteString("\t// Variáveis Locais\n")
		// Declara variaveis ordenadas para ficar bonito
		for i := 0; i < fn.TempCount; i++ {
			name := fmt.Sprintf("t%d", i)
			typeStr, exists := tempTypes[name]
			if !exists {
				typeStr = "interface{}"
			} // Fallback

			// Gera: var t0 int64
			e.Output.WriteString(fmt.Sprintf("\tvar %s %s\n", name, typeStr))
		}
		// Silenciador de variáveis não usadas do Go (hack clássico de transpilers)
		e.Output.WriteString("\t_, _ = ")
		for i := 0; i < fn.TempCount; i++ {
			if i > 0 {
				e.Output.WriteString(", ")
			}
			e.Output.WriteString(fmt.Sprintf("t%d", i))
		}
		e.Output.WriteString("\n\n")
	}

	// 3. Corpo da Função
	for _, instr := range fn.Instructions {
		e.emitInstruction(instr)
	}

	e.Output.WriteString("}\n\n")
}

// Analisa o IR para descobrir o tipo de cada t0, t1, t2...
func (e *Emitter) collectTempTypes(fn *ir.Function) map[string]string {
	types := make(map[string]string)
	for _, instr := range fn.Instructions {
		if instr.Result != nil && instr.Result.Kind == ir.OpTemp {
			// O otimizador ou builder DEVE ter preenchido instr.Result.Type
			if instr.Result.Type != nil {
				types[instr.Result.Value] = ToGoType(instr.Result.Type)
			} else {
				// Se o tipo veio nulo, tentamos inferir pelo OpCode (perigoso, mas necessário se o semantic falhar)
				types[instr.Result.Value] = inferTypeFromOp(instr.Op)
			}
		}
	}
	return types
}

func (e *Emitter) emitInstruction(instr *ir.Instruction) {
	if instr.Op == ir.LABEL {
		e.Output.WriteString(fmt.Sprintf("%s:\n", instr.Arg1.Value))
		return
	}

	e.Output.WriteString("\t")

	// Lado Esquerdo (Assignment)
	if instr.Result != nil {
		e.Output.WriteString(instr.Result.Value + " = ")
	}

	arg1 := safeOp(instr.Arg1)
	arg2 := safeOp(instr.Arg2)

	switch instr.Op {
	// Aritmética Nativa (Super Rápida)
	case ir.ADD:
		e.Output.WriteString(fmt.Sprintf("%s + %s", arg1, arg2))
	case ir.SUB:
		e.Output.WriteString(fmt.Sprintf("%s - %s", arg1, arg2))
	case ir.MUL:
		e.Output.WriteString(fmt.Sprintf("%s * %s", arg1, arg2))
	case ir.DIV:
		e.Output.WriteString(fmt.Sprintf("%s / %s", arg1, arg2))

	// Lógica
	case ir.EQ:
		e.Output.WriteString(fmt.Sprintf("%s == %s", arg1, arg2))
	case ir.NEQ:
		e.Output.WriteString(fmt.Sprintf("%s != %s", arg1, arg2))
	case ir.LT:
		e.Output.WriteString(fmt.Sprintf("%s < %s", arg1, arg2))
	case ir.GT:
		e.Output.WriteString(fmt.Sprintf("%s > %s", arg1, arg2))

	case ir.MOV:
		e.Output.WriteString(arg1)

	// Controle de Fluxo
	case ir.JMP:
		e.Output.WriteString(fmt.Sprintf("goto %s", instr.Arg1.Value))
	case ir.JMP_FALSE:
		// Go exige bool explícito no if
		e.Output.WriteString(fmt.Sprintf("if !%s { goto %s }", arg1, instr.Arg2.Value))
	case ir.JMP_TRUE:
		e.Output.WriteString(fmt.Sprintf("if %s { goto %s }", arg1, instr.Arg2.Value))

	// Chamadas
	case ir.CALL:
		// Assume-se que instr.Args contenha os operandos dos argumentos
		args := []string{}
		e.Output.WriteString(fmt.Sprintf("%s(%s)", instr.Arg1.Value, strings.Join(args, ", ")))

	case ir.RET:
		if instr.Arg1 != nil {
			e.Output.WriteString(fmt.Sprintf("return %s", arg1))
		} else {
			e.Output.WriteString("return")
		}

	// Structs e Arrays
	case ir.GET_FIELD:
		// t1 = user.age -> t1 = user.Age
		field := strings.Title(instr.Arg2.Value) // Go export rule
		e.Output.WriteString(fmt.Sprintf("%s.%s", arg1, field))

	case ir.GET_INDEX:
		e.Output.WriteString(fmt.Sprintf("%s[%s]", arg1, arg2))

	case ir.MAKE_MAP:
		// t1 = make(map[string]int64)
		goType := ToGoType(instr.Result.Type)
		e.Output.WriteString(fmt.Sprintf("make(%s)", goType))

	// Builtins (Mantemos helpers apenas para coisas complexas)
	case ir.LEN:
		e.Output.WriteString(fmt.Sprintf("int64(len(%s))", arg1))

	default:
		e.Output.WriteString(fmt.Sprintf("/* OP %d Unknown */", instr.Op))
	}

	e.Output.WriteString("\n")
}

// Utilitários

func inferTypeFromOp(op ir.OpCode) string {
	// Fallback simples se o tipo faltar no IR
	switch op {
	case ir.EQ, ir.NEQ, ir.LT, ir.GT, ir.LE, ir.GE:
		return "bool"
	default:
		return "int64" // Chute educado
	}
}

func sanitizeName(n string) string {
	// Evita conflito com keywords do Go
	if n == "func" || n == "var" || n == "type" || n == "go" {
		return "u_" + n
	}
	return n
}

func safeOp(op *ir.Operand) string {
	if op == nil {
		return ""
	}

	if op.Kind == ir.OpLiteral {
		// Tratamento de string literal
		if op.Type != nil && strings.Contains(semantic.StringifyType(op.Type), "string") {
			if !strings.HasPrefix(op.Value, "\"") {
				return "\"" + op.Value + "\""
			}
		}
		return op.Value
	}
	if op.Kind == ir.OpVar {
		return sanitizeName(op.Value)
	}
	return op.Value
}
